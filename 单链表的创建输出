//
//  链表的定义以及操作.c
//  C
//
//  Created by MacBook on 2019/10/18.
//  Copyright © 2019 MacBook. All rights reserved.
//
//https://blog.csdn.net/qq_41028985/article/details/82859199
#include "链表的定义以及操作.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/malloc.h>



//单链表的定义
typedef struct Node{
    int data;    //数据域
    struct Node *next;  //指针域
}Lnode, *Linklist;


void Illustrate(Linklist head) {
    Linklist tem = head;                 //  将头指针的地址赋给临时的指针
    while (tem->next != NULL) {       //  指向最后一个结点的指针域时会停止
        tem = tem->next;               //  结点不断向后移动
        printf("%d\n", tem->data);
    }
}

Linklist Creat_list(Linklist head) {
    head = (Linklist)malloc(sizeof(Lnode));      //  为头指针开辟内存空间
    Lnode *node = NULL;                    //  定义新结点
    int count = 0;                          //  创建结点的个数
    head->next = NULL;
    node = head->next;                  //  将最后一个结点的指针域永远保持为NULL
    printf("Input the node number: ");
    scanf("%d", &count);
    for (int i = 0; i < count; i++) {
        node = (Linklist)malloc(sizeof(Lnode));     //  为新结点开辟内存空间
        node->data = i;               //  为新结点的数据域赋值
        node->next = head->next;          //  将头指针所指向的下一个结点的地址，赋给新创建结点的next
        head->next = node;          //  将新创建的结点的地址赋给头指针的下一个结点
    }
    return head;
}

//尾插法代码
Linklist Creat_list_2(Linklist head) {
    head = (Linklist)malloc(sizeof(Lnode));          //  为头指针开辟内存空间
    Linklist node = NULL;           //  定义结点
    Linklist end = NULL;            //  定义尾结点
    head->next = NULL;              //  初始化头结点指向的下一个地址为 NULL
    end = head;                     //  未创建其余结点之前，只有一个头结点
    int count = 0 ;                 //  结点个数
    printf("Input node number: ");
    scanf("%d", &count);
    for (int i = 0; i < count; i++) {
        node = (Linklist)malloc(sizeof(Lnode));          //  为新结点开辟新内存
        node->data = i;                                  //  新结点的数据域赋值
        end->next = node;
        end = node;
    }
    end->next = NULL;
    return head;
}

//查找链表倒数第K个节点，思路，ppre和pcur相差k个数值，然后依次往后取数，直到pcur为空为止，这样ppre就是倒数第k个//数值
int SearchK(Lnode *list ,int k){
    Lnode *ppre=list->next;
    Lnode *pcur=list->next;
    int count=0;
    
    while(NULL !=pcur){
        ++count;
        if(count>k)
            ppre=ppre->next;
        pcur=pcur->next;
    }
        if(count<k)
            return 0;
            else
            {
                printf("%d\n",ppre->data);
                return 1;
            }
}






int main() {
    Linklist head = NULL;            //  链表的头指针
    head = Creat_list_2(head);        //  创建链表
    Illustrate(head);               //  输出每个结点的数据域
    system("pause");
    SearchK(head,3);
    //printf("%d\n",SearchK(head,3));
    return 0;
    
}



